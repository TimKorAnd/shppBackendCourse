shpp backend course 2020
=====================================


(еще есть вариант Ирины)


основная идея:


Начинаем с чистого языка, попутно ПРАКТИКОЙ изучая концепции современного веба с низов. 
Через самописный фреймворк и подработку к уже написанному фронту приходим к современному фреймворку и сопутствующим понятиям современного бэкендщика (например миграции или очереди). 
На этапе деланья своего проекта изучаем основы devops, чтобы понимать как это все деплоится, обслуживается, а как это надо делать.
В дальнейшем можно изучать разрозненные но важные темы, типа секьюрити, или редис, или докер, т.д.


этапы обучения:
1. изучаем язык
   * в заданиях, не намекающих на веб, вводим понятия TCP, HTTP (body headers method response code virtual hosts), (возможно)JSON и как это все работает. 
без сети изучаем процесс обработки хттп запроса с самого нуля. 
   2. создаем свое первое веб-приложение с нуля, без чужих либ
   * используем xampp? ну или можно как угодно, лишь бы 
apache + mysql + php
можно если хочется настроить себе
nginx + php-fpm + mariadb + php
   * используем https://www.getpostman.com/downloads/ чтобы работать с нашим бекендом
   * сначала работаем с файлами, потом с SQL (идея умеет подключаться туда)
   * сначала все обрабатываем маленькими файликами, потом учимся делать всё через самописный роутер и query string
   * изучаем composer чтобы например корсы сделать какие положено, или там еще полезную либу подключить, ну или линтер забецать
   * учимся соответствовать спеке и делаем бек к подготовленному фронту (может какой-то todolist), учимся юзать chrome devtools чтобы понимать что к чему
      * можно на фронт заложить несложную ошибку для исправления бекендщиком
      * cookie для авторизации, обратить внимание как это работает
      3. пишем свой фреймворк
      * шаблонизатор
      * роутер 2.0
      * MVC
      * миграции?
      * стоит ли тут изучать основы html/css/javascript?
      * изучите топ 50 пакетов композера
      * загрузка файлов
      * сессии?, хеш 
      * крон для чего?? - 
бекап бд раз в день, GC soft deletion'ov, stats recalc 
      * стар левел:
         * из пакетов композера соберите свой фреймворк, заменяя свои компоненты на уже готовые реализации
         * школьная библиотека как проект, или свой инет магазин
         * возможность по имени книги подгрузить картинку из инета
         * импорт из экселя в БД
         4. переходим на ларавел
         * изучаем REST
         * router: prefix, middleware, route parameters
         * blade
         * swagger
         * миграции
         * artisan
         * Реализовать аппликуху нужно так, чтоб она могла без проблем запускаться в подпапке на сервере, а не только в корневой директории веб сервера
         * cron
         * cors
         * OOP
         * что еще? @irina говорит что надо: контроллеры, элокент (вся работа с базой), отправка почты, апи (типа телеграм нотификаций), очереди, команды крона, мидлвееры (на приеме запроса и выдаче ответа), редис, работа с файловой системой, стандратная авторизация и гугл, сделать свое апи
         * Костя говорит: Добавил бы еще туда ознакомление с сервис-провайдерами, валидацией запросов и событиями со слушателями. 
https://laravel.com/docs/6.x. Там в принципе по каждому пункту все нормально расписано
         *             5. devops
            * ec2 сервер, nginx router, letsencrypt, свой домен + route53
            * phpmyadmin
            * curl :))
            6. advanced
            * security
            * docker
            * google auth
            * ansible?
            * redis and caching
            * linux
            * jwt
            7. делаем проект вместе


этап 1
====================================




на этом этапе юзаем php, не юзаем xampp/apache.
мы пишем консольные программки.
начиная со второй задачи, они будут принимать данные в формате HTTP запроса. 
начиная со третьей задачи, они будут давать на вывод данные в формате HTTP ответа, 
что это такое - см. дальше.
	



            1. установите себе пхп так, чтобы с консоли вы могли вызывать команду php, и
            1. если вы создадите файл hello.php с содержимым
<?php echo 1+2;
            2. и в той же папке запустите команду php hello.php
            3. то должны увидеть в результате 3 на экране
            4. ХОРОШИЕ НОВОСТИ: 
в будущем ваши пхп-файлы будут запускаться сами, при запросах из интернета (например http://вашсайт/a.php будет запускать файл a.php из корня вашего сайта)
            5. ваши пхп программы будут запускаться на далеком сервере, каждый раз когда будет приходить запрос из интернета (обычно с фронта вашего сайта).
чтобы разобраться что такое фронт и бек, вот 3хминутное видео:
https://www.youtube.com/watch?v=9qqIE5ynSr0

супертема: https://github.com/shpp/php-backend-course-2020/tree/master/level1
эта штука умеет тестировать ваши домашки.


               2. завершите файл

<?php


// не обращайте на эту функцию внимания
// она нужна для того чтобы правильно считать входные данные
function readHttpLikeInput() {
    $f = fopen( 'php://stdin', 'r' );
    $store = "";
    $toread = 0;
    while( $line = fgets( $f ) ) {
        $store .= preg_replace("/\r/", "", $line);
        if (preg_match('/Content-Length: (\d+)/',$line,$m)) 
            $toread=$m[1]*1; 
        if ($line == "\r\n") 
              break;
    }
    if ($toread > 0) 
        $store .= fread($f, $toread);
    return $store;
}


$contents = readHttpLikeInput();


function parseTcpStringAsHttpRequest($string) {
    return array(
        "method" => ...,
        "uri" => ...,
        "headers" => ...,
        "body" => ...,
    );
}


$http = parseTcpStringAsHttpRequest($contents);
echo(json_encode($http, JSON_PRETTY_PRINT));
	

                  6. по факту надо написать функцию parseTcpStringAsHttpRequest($string) которая принимает строку,
                  7.  а возвращает array состоящий из элементов:
                  * method - строка
                  * uri - строка
                  * headers - массив пар строк (в примере это то что слева от ": " и то что справа)
                  * body - строка
                  8. пример:
GET /doc/test.html HTTP/1.1
Host: www.test101.com
Accept: image/gif, image/jpeg, */*
Accept-Language: en-us
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0
Content-Length: 35


bookId=12345&author=Tan+Ah+Teck
	                  * GET - method
                  * /doc/test.html - это uri
                  * дальше идут строки header'ов, где каждый хедер это 
название_хедера: значение_хедера
                  * bookId=12345&author=Tan+Ah+Teck - это body, отделяется одной пустой строкой от хедеров
                     9. не делайте что-то суперуниверсальное поддерживающее edge-кейсы. Сделайте абы как и двигаем дальше. 
Если есть желание, вот парочка эдж кейсов которые _советуем_ обрабатывать:
                        * боди (и пустой строки над ним) может и не быть
                        * хедеров может не быть
                        10. напишите тест-скрипт, который проверяет правильность работы вашей программы, притом первее чем вы напишете функцию parseHttpRequest.
                        * напишите к нему заглушечную имплементацию parseHttpRequest чтобы оттестировать его.
                        11. ХОРОШИЕ НОВОСТИ:
Вы написали велосипед)
Подобные штуки будут парситься за вас, но, разобравшись с этой задачей, вы навсегда поймете что HTTP-запрос по факту это просто кусок текста, и поймете его основную структуру.
...Это задание раскрывает перед вами протокол HTTP, с которым мы постоянно будем работать (в этом формате вам будут приходить сообщения-команды-запросы от фронта веб-сайта).
                        12. подробности для интересующихся, что это всё за странные придуманные форматы и знаки:
                           * что такое ХТТП - https://developer.mozilla.org/ru/docs/Web/HTTP/Overview

                              3. напишите функцию processHttpRequest($method, $uri, $headers, $body) которая проверяет что 
                              1. если 
                              * метод = GET
                              * uri = /sum?nums=.....разделенные запятыми числа....
                              * body = неважно
                              * headers = неважно
                              2. то надо выдать на экран следующий кусок текста (если сумма=5)
HTTP/1.1 200 OK
Date: Sun, 18 Oct 2012 10:36:20 GMT -- тут текущее время
Server: Apache/2.2.14 (Win32)
Content-Length: 1
Connection: Closed
Content-Type: text/html; charset=utf-8


5
	                              3. а если uri не начинается с /sum то надо выдать
HTTP/1.1 404 Not Found
Date: Sun, 18 Oct 2012 10:36:20 GMT -- тут текущее время
Server: Apache/2.2.14 (Win32)
Content-Length: 9
Connection: Closed
Content-Type: text/html; charset=utf-8


not found
	                              4. по факту надо написать вот такой пхп файл
<?php
function readHttpLikeInput() {
    // ну это уже написано за вас
}


$contents = readHttpLikeInput();


function outputHttpResponse($statuscode, $statusmessage, $headers, $body) {
    ...
    echo ...;
}


function processHttpRequest($method, $uri, $headers, $body) {
    ...
    outputHttpResponse(...);
}


function parseTcpStringAsHttpRequest($string) {
    // ну это вы уже написали
}


$http = parseTcpStringAsHttpRequest($contents);
processHttpRequest($http["method"], $http["uri"], $http["headers"], $http["body"]);


	

                              5. а если нет ?nums= то надо выдать подобное, только 
немного другой http код - 400 Bad Request
                                 * как и в случае со значением метода не-GET
                                 6. подумайте, можно ли сделать функцию 
outputHttpResponse($statuscode, $statusmessage, $headers, $body) чтобы упростить себе жизнь и не заниматься собиранием этой сложной строчки.
Думаю вы уже догадались что будет в параметрах, 
                                    * иначе смотрите сюда:
https://developer.mozilla.org/ru/docs/Web/HTTP/Overview#HTTP_%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F
                                       7. убедитесь что Content-Length соответствует размеру body всегда
                                       8. для теста своей программы воспользуйтесь вот этими входными данными (не забудьте в конце одну пустую строку):
GET /sum?nums=1,2,3 HTTP/1.1
Host: student.shpp.me


	

                                       9. ХОРОШИЕ НОВОСТИ:
вы написали велосипед :)
мы тут впервые генерируем HTTP-ответ, и в вебе именно так общаются сервер отвечает на запрос клиента, но хвала богам - подобные штуки уже сделаны за вас, 
и вам нужно будет в будущем делать только самое главное - писать логику (в данном случае посчитать сумму из уже разобранного на части запроса). Корректный ответ будет сформирован автоматически, но не особо намаханнее чем то как это реализовали вы в функции outputHttpResponse.
                                       10. подробности для интересующихся, что это всё за странные придуманные форматы и знаки:
                                          * больше про заголовки тут:
HTTP заголовки
                                          * больше про понятие query string тут:
https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web_RU#Синтаксис_Унифицированных_Идентификаторов_Ресурсов_URI

                                             4. перепишите функцию processHttpRequest($method, $uri, $headers, $body)
которая будет принимать что-то вроде

POST /api/checkLoginAndPassword HTTP/1.1
Accept: */*
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/4.0
Content-Length: 35



login=student&password=12345
	

                                                11. и естественно если uri не такой, или content-type не такой, то надо вернуть ошибку как описывалось в предыдущем задании
                                                12. вообще что нужно сделать: извлечь из $body значения логина и пароля, потом с помощью file_get_contents открыть локальный файлик passwords.txt (где в формате username:password на каждой строчке хранятся пары), и найти там пришедшую пару, и как результат сформировать и вывести HTTP ответ с кодом 200, и следующим body
<h1 style="color:green">FOUND</h1>
	                                                13. возвращаемый текст - это текст в формате HTML (фронтэндщики пользуются этой штукой чтобы описывать красивые страницы), а для бекендщиков это просто кусок текста
                                                14. подумайте что выдать юзеру если пара логин-пароль не найдена в файлике.
                                                15. если файла passwords.txt нет, то выдать код 500 - Internal Server Error
                                                16. ХОРОШИЕ НОВОСТИ:
вы написали велосипед :)
вы только что изучили как общается фронт, когда делает запрос на бек после заполнением юзером какой-то формы. Естественно парсинг body будет делаться за вас, и вам останется реализовать только самую бизнес-логику программы - собственно искать в базе данных пары логин-пароль. Фронтэндщики дадут вам готовый HTML, поэтому вам не придется придумывать что именно выдавать на выход, кроме собственно самих данных.
                                                17. подробности для интересующихся, что это всё за странные придуманные форматы и знаки:
                                                   * https://habr.com/ru/post/236837/ - про то что такое form data и POST-запросы
                                                   * HTML 
                                                   * иногда бекенд возвращает HTML чтобы браузер его сразу и нарисовал. А иногда бекенд возвращает чисто данные, чтобы код фронтэнд-разработчика их взял, и вывел красивенько.
это называется ajax и схватить саму суть можно тут:
https://habr.com/ru/post/14246/



                                                      5. ОПЦИОНАЛЬНАЯ ЗАДАЧА, можно не делать
напишите функцию processHttpRequest($method, $uri, $headers, $body)
которая будет возвращать файлы из некоторой базовой папки (например текущей), например если uri = /hey/file.txt то с помощью file_get_contents должен быть прочитан файл file.txt из подпапки hey и возвращен с кодом 200 как обычно. Если файла нет, то 404.
                                                         1. В зависимости от хедера Host надо выбирать разные базовые папки.
                                                         * для значений начинающихся с student.shpp.me надо брать подпапку student
                                                         * для значений начинающихся с another.shpp.me надо брать подпапку another
                                                         * для всех остальных значений хедера Host можно брать подпапку else, и ничего туда не ложить и даже папку не создавать, чтобы возвращало 404 в любых случаях.
                                                         2. мы получаем примитивный сервер файлов, поддерживающий концепцию виртуальных хостов
                                                         3. кстати, если в файл, например, hello.html положить что-то типа 
<link href="https://getbootstrap.com/docs/4.0/dist/css/bootstrap.min.css" rel="stylesheet">
<div class="text-center cover-container d-flex h-100 flex-column">
  <header class="mb-auto inner"></header>
  <main  class="inner cover">
    <h1 class="cover-heading">Привет это заголовок.<br/></h1>
    <a href="#" class="lead btn btn-lg btn-secondary">Эта кнопка не работает :)</a>
  </main>
  <footer class="mt-auto inner"/>
</div>


	... и это будет красиво рисоваться браузерами! если им конечно это доставить по всем правилам HTTP... ну а чтобы шарить эту магию - нужно изучать фронтэнд. Бэкендщикам же это не нужно знать.
                                                         4. если урл равен просто слешу, то считать что урл = /index.html
                                                         5. ОПЦИОНАЛЬНО по желанию сделайте
                                                         * 404 если не найдено
                                                         * 403 если выход за пределы домашней директории ;)
                                                         * https://habr.com/ru/post/253049/
                                                         6. ХОРОШИЕ НОВОСТИ:
                                                         * это настолько не-бизнес-логическая задача, что для нее даже не надо будет писать код.
вы будете использовать готовые программы типа nginx или apache для того чтобы сервить файлы, анализировать Host хедеры и всякие edge cases и не делать эту всю рутину.
это называется "хостить статические файлы" (в том плане что бек будет просто выдавать содержимое файлов, бездумно) или просто "сервить статику" 
                                                            7. больше про виртуальные хосты можно почитать тут:
                                                            * https://habr.com/ru/post/215117/ - искать по слову Host
                                                            * https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8/Host
                                                            * https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%85%D0%BE%D1%81%D1%82%D0%B8%D0%BD%D0%B3




тестировать это можно автотестирующими тулзами, или, чтобы впечатлить человека и показать ему связь с вебом, можно сделать следующее...


(требует установленного socat типа yum install socat / apt-get install socat)
на сервере выполнить:
$ socat TCP4-LISTEN:5556,reuseaddr,fork EXEC:"php /path/to/file.php"


как результат - можно идти в браузере на http://serverip:5556 и, если ответ - вменяемый HTTP, то получить красивый результат
аналогично можно будет делать подачу на вход программы данных в формате HTTP запроса.


... для того чтобы сделать такую крутоту, надо будет сделать ряд работы - научить людей заливать их файлики на наш сервер, запускать оттуда сокат-команды, и т.д.
не знаю насколько это будет круто, и насколько сложно.
но какая-то крутенькая наглядность в этом будет, мне кажется.
	



... пожалуй мы готовы к пхп и наелись низкоуровневой фигни (?). Добро пожаловать в мир LEMP/LAMP, и для начала пожалуйста поставьте себе какой-нибудь XAMPP, или просто Apache, или еще что-то, по инструкции из интернета (есть видео инструкции!) так, чтобы при запросе на ваш сервер хоть как-то отрабатывал PHP (например скрипт из самого первого домашнего задания, где echo 1+2) и вы в браузере видели результат в виде числа 3.
прежде чем делать это, зацените:
                                                            * апач за вас будет сервить файлы из домашки №5
                                                            * апач за вас будет не просто сервить php файлы, а запускать их, и уже их вывод выдавать в браузер
                                                            * апач за вас будет формировать http response, все хедеры, статус коды, и вам останется только формировать body (с помощью команды echo)
                                                            * апач за вас будет парсить входящий http запрос, и вам нужно будет использовать уже готовые для употребления глобальные переменные $_GET, $_POST и другие


последнее домашнее задание (#6).
                                                            * на вашем апаче сделайте примитивный сайтик, который при заходе в браузере на какую-то ссылку (ваш скрипт) будет выдавать счетчик заходов на эту ссылку.
                                                            * т.е. открываю в первый раз урлу типа http://localhost/file.php и вижу на экране 0, открываю еще раз урлу - и уже вижу 1.
                                                            * для реализации этого дз вам потребуется file_get_contents и file_put_contents


(#7) опциональная практика
переведите свои предыдущие домашки на апач (в основном удалением лишнего кода и переходом на $_GET и $_POST). 










этап №2:
=====================================


                                                            * будем делать серверную часть для туду приложения. Как видим нам понадобится хранить на сервере набор тудушек, и также их состояние (сделано или не сделано)
                                                            * работать будем с форматом JSON, в пхп есть две суперкоманды команды для легкой работы с этим форматом
                                                            * самая базовая версия должна поддерживать добавление удаление изменение и просмотр тудушек
                                                            * /api/v1/getItems.php должно вернуть в формате json 
{ items: [ { id: 22, text: "...", checked: true } , ... ] }
                                                            * /api/v1/addItem.php должен принимать json { text: "..." } а возвращать { id: 23 } или типа того 
                                                               * кстати, на каждую генерацию нового айтема должен быть новый айди, они не должны повторяться никогда. Для начала можете в отдельном файле хранить последний айди, и инкрементить его когда надо.
                                                               * /api/v1/changeItem.php должен принимать json
{ id: 22, text: "...", checked: true }
а возвращать
{ "ok" : true }
этот endpoint используется для изменения текста/статуса записи
                                                               * /api/v1/deleteItem.php должен принимать json
{ id: 22 }
а возвращать
{ "ok" : true }
                                                                  * поначалу реализуйте через хранение в .json файле
                                                                  * потом храните в mysql
                                                                  * попробуйте варианты с mysqli и с PDO и опишите, какой вам больше понравился и почему
                                                                  * сделайте так чтобы конфигурация доступа к БД была в одном месте, и подключалась к другим пхп файлам посредством require или что там в пхп
                                                                  * напишите скрипт который настраивает БД (создает таблицы)
                                                                  * ваш бекенд должен поддерживать CORS чтобы можно было обращаться к нему с другого домена
                                                                  * после изначального релиза научите ваш сервис работать с несколькими юзерами, для этого вам надо будет сделать авторизацию и хранить ключи сессий в cookie.
                                                                  * /api/v1/login.php принимает 
{ "login": "...", "pass": "..."  }
и возвращает 
{ "ok": true } 
а также заюзайте сессии в пхп чтобы хранить инфу о том кто это залогинился
                                                                  * /api/v1/logout.php ничего не принимает, но в итоге рубит сессию
                                                                  * /api/v1/register.php принимает 
{ "login": "...", "pass": "..."  }
и возвращает 
{ "ok": true }
                                                                     * пора учиться обрабатывать ошибки
                                                                     * если происходит какая-то стремная ошибка на сервере (нет файла который должен быть или еще что), то надо возвращать HTTP код 500 и json с телом { "error": "...." }
                                                                     * если юзер ошибся и прислал какую-то фигню, то надо возвращать HTTP код 400 и json с телом { "error": "...." }
                                                                     * для начала реализуйте каждый endpoint в отдельном файле, но потом реализуйте всё более умно, сделав следующий эндпойнт:
/api/v2/router.php?action=login|logout|getItems|...
и по query string вызывайте уже конкретную функцию
                                                                     * воспользуйтесь готовым фронтом (его пока нет! он в разработке, последняя инфа у @rshmelev), чтобы протестировать своё детище.
                                                                        * помните, что мы могли заложить некоторые баги в фронт, чтобы вы поучились тестировать взаимодействие фронта и бэкенда (гуглите инфу по chrome devtools) и возможно фиксить фронт (там несложно))
                                                                        * изучите, поддерживаете ли вы тудушки на русском
                                                                        * БЕГЛО почитайте про SQL инъекции, подумайте все ли у вас ок
                                                                        * БЕГЛО почитайте про XSS, подумайте все ли у вас ок
                                                                        * полезные ссылки которые помогут вам и которые надо обязательно прочитать и учесть:
                                                                        * https://websitebeaver.com/php-pdo-vs-mysqli
                                                                        * https://www.tutorialspoint.com/http/http_status_codes.htm 
                                                                        * когда будете работать с .json-файлом, подумайте, что будет если одновременно придет на сервер два запроса на добавление новых айтемов. 
                                                                        * эта штука называется race condition, и бороться с ней надо разными lock'ами и транзакциями, хотя некоторые вещи намного проще авто-лечаться переходом на MySQL БД вместо использования файликов. 
                                                                        * когда пишете свой код, представляйте будто каждую секунду на сервер валит по 1000 разных запросов, и подумайте не получится ли так что у вас данные будут потеряны/продублированы/неконсистентны из-за этого.